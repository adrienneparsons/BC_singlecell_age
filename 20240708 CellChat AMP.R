# Make the TNBC and ER+ CellChat objects

# Load the required libraries
library(CellChat)
library(patchwork)
library(VennDiagram)
library(RColorBrewer)
library(ComplexHeatmap)

# -------------------------------------------------------------------------
# Create the TNBC CellChat object
cellchatTN.old <- readRDS("/Users/addie/Dropbox (Partners HealthCare)/McLab lab meeting 2020/Esther Sauras Colon/CellChat files/cellchatTN.old_computeCommunProb_psize_TRUE.Rdata")
cellchatTN.young <- readRDS("/Users/addie/Dropbox (Partners HealthCare)/McLab lab meeting 2020/Esther Sauras Colon/CellChat files/cellchatTN.young_computeCommunProb_psize_TRUE.Rdata")

# Set the ligand-receptor interaction database
CellChatDB <- CellChatDB.human 
showDatabaseCategory(CellChatDB)

# use a subset of CellChatDB for cell-cell communication analysis
# use all CellChatDB for cell-cell communication analysis
CellChatDB.use <- CellChatDB # simply use the default CellChatDB

# set the used database in the object
cellchatTN.old@DB <- CellChatDB.use
cellchatTN.young@DB <- CellChatDB.use

# Set up parallel processing
future::plan("multisession", workers = 4)
options(future.globals.maxSize = 600 * 1024^2) # default: 500 * 1024^2 = 500 MiB

# -------------------------------------------------------------------------
# Load the cellchat objects previously generated by the BC data_CellChat_allobjects_psize script and add to a list
object.list <- list(TNBC.young = cellchatTN.young, TNBC.old = cellchatTN.old)

# Check min.cells
lapply(object.list, function(x) summary(x@idents))
# Filter out the cell-cell communication if there are only few number of cells in certain cell groups
object.list <- lapply(object.list, function(x) filterCommunication(x, min.cells = 3))
object.list <- lapply(object.list, function(x) computeCommunProbPathway(x))
object.list <- lapply(object.list, function(x) aggregateNet(x))

# liftCellchat() if necessary
lapply(object.list, function(x) length(levels(x@idents)))
object.list[[1]] <- liftCellChat(object.list[[1]], levels(object.list[[2]]@idents))

# Merge CellChat object of each dataset together
cellchatTNBC <- mergeCellChat(object.list, add.names = names(object.list))

# Repeat for ER+
# Create the ER+ CellChat object
cellchatER.old <- readRDS("/Users/addie/Dropbox (Partners HealthCare)/McLab lab meeting 2020/Esther Sauras Colon/CellChat files/cellchatER.old_computeCommunProb_psize_TRUE.Rdata")
cellchatER.young <- readRDS("/Users/addie/Dropbox (Partners HealthCare)/McLab lab meeting 2020/Esther Sauras Colon/CellChat files/cellchatER.young_computeCommunProb_psize_TRUE.Rdata")

# Set the ligand-receptor interaction database
CellChatDB <- CellChatDB.human 
showDatabaseCategory(CellChatDB)

# use all CellChatDB for cell-cell communication analysis
CellChatDB.use <- CellChatDB # simply use the default CellChatDB

# set the used database in the object
cellchatER.old@DB <- CellChatDB.use
cellchatER.young@DB <- CellChatDB.use

# Set uup parallel processing
future::plan("multisession", workers = 4) # do parallel
options(future.globals.maxSize = 600 * 1024^2) # default: 500 * 1024^2 = 500 MiB

# Add the loaded CellChat objects to a list
object.list <- list(ER.young = cellchatER.young, ER.old = cellchatER.old)

# Check min.cells
lapply(object.list, function(x) summary(x@idents))
# Filter out the cell-cell communication if there are only few number of cells in certain cell groups
object.list <- lapply(object.list, function(x) filterCommunication(x, min.cells = 3))
object.list <- lapply(object.list, function(x) computeCommunProbPathway(x))
object.list <- lapply(object.list, function(x) aggregateNet(x))

# liftCellchat() if necessary
lapply(object.list, function(x) length(levels(x@idents)))
object.list[[1]] <- liftCellChat(object.list[[1]], levels(object.list[[2]]@idents))

# Merge CellChat object of each dataset together
cellchatER <- mergeCellChat(object.list, add.names = names(object.list))

# Use these new objects for additional analyses


